{
  "source": "quant_finance_risk_management",
  "created_at": "2025-11-09",
  "total_pairs": 1,
  "description": "Risk Management Q&A - Conditional Value at Risk (CVaR) for cryptocurrency portfolios",
  "qa_pairs": [
    {
      "pair_id": "quant_risk_002",
      "topic": "Conditional Value at Risk CVaR Expected Shortfall cryptocurrency tail risk coherent measure",
      "question": "What is Conditional Value at Risk (CVaR/Expected Shortfall), how does it improve upon traditional VaR, and how should it be applied to cryptocurrency portfolio risk management?",
      "answer": "Conditional Value at Risk (CVaR), also known as Expected Shortfall (ES) or Average Value at Risk (AVaR), is a risk measure that quantifies the expected loss given that a loss exceeds the VaR threshold. Unlike VaR which only tells you the threshold, CVaR tells you how bad losses are expected to be when they exceed that threshold. CVaR has become the preferred risk measure in modern risk management because it is a coherent risk measure and better captures tail risk. This is especially critical for cryptocurrencies, which exhibit extreme tail events. Here's the comprehensive guide:\n\n**CVaR Theory:**\n\n**Formal Definition:**\nCVaR_Œ± = E[L | L ‚â• VaR_Œ±]\n\nWhere:\n- CVaR_Œ± = Conditional VaR at confidence level Œ±\n- L = Portfolio loss\n- VaR_Œ± = Value at Risk at level Œ±\n- E[¬∑|¬∑] = Expected value conditional on\n\n**Interpretation:**\n\"CVaR is the average loss in the worst (1-Œ±)% of cases.\"\n\nExample: 95% CVaR = $15,000\n- Meaning: When daily losses exceed the 95% VaR threshold, the average loss is $15,000\n- Compare to VaR which only tells threshold, not average severity\n\n**Why CVaR > VaR:**\n\n1. **Coherent Risk Measure** - CVaR satisfies all four axioms:\n   - Monotonicity: More loss = more risk ‚úì\n   - Translation invariance: Adding cash reduces risk ‚úì\n   - Homogeneity: Doubling position doubles risk ‚úì\n   - **Subadditivity: Diversification reduces risk ‚úì**\n   \n   VaR violates subadditivity (portfolio VaR can > sum of individual VaRs)\n\n2. **Captures Tail Severity** - VaR ignores how bad losses beyond threshold are\n\n3. **Optimization-Friendly** - CVaR is convex, can be minimized efficiently\n\n**Calculating CVaR:**\n\n**1. Historical CVaR (Non-parametric)**\n\n```python\nimport numpy as np\nimport pandas as pd\nfrom scipy import stats\nimport matplotlib.pyplot as plt\n\ndef historical_cvar(returns, confidence_level=0.95):\n    \"\"\"\n    Calculate CVaR using historical simulation\n    \n    Args:\n        returns: Array or Series of historical returns\n        confidence_level: Confidence level (e.g., 0.95 = 95%)\n    \n    Returns:\n        CVaR as a positive number (expected tail loss)\n    \"\"\"\n    # Calculate VaR first\n    var_percentile = 1 - confidence_level\n    var = -np.percentile(returns, var_percentile * 100)\n    \n    # CVaR = average of all losses beyond VaR\n    losses = -returns  # Convert to losses (positive = loss)\n    tail_losses = losses[losses >= var]\n    cvar = tail_losses.mean()\n    \n    return cvar, var\n\n# Example: BTC portfolio\nnp.random.seed(42)\nbtc_returns = np.random.normal(0.001, 0.04, 365)  # Daily returns\n\ncvar_95, var_95 = historical_cvar(btc_returns, 0.95)\ncvar_99, var_99 = historical_cvar(btc_returns, 0.99)\n\nprint(\"üìä HISTORICAL CVAR\")\nprint(\"=\" * 70)\nprint(f\"\\n95% Confidence Level:\")\nprint(f\"  VaR:  {var_95*100:.2f}% (threshold)\")\nprint(f\"  CVaR: {cvar_95*100:.2f}% (average loss beyond VaR)\")\nprint(f\"  Ratio: CVaR/VaR = {cvar_95/var_95:.2f}x\")\n\nprint(f\"\\n99% Confidence Level:\")\nprint(f\"  VaR:  {var_99*100:.2f}%\")\nprint(f\"  CVaR: {cvar_99*100:.2f}%\")\nprint(f\"  Ratio: CVaR/VaR = {cvar_99/var_99:.2f}x\")\n\n# Dollar CVaR for $100,000 portfolio\nportfolio_value = 100000\nprint(f\"\\nFor ${portfolio_value:,} portfolio (95% level):\")\nprint(f\"  VaR:  ${var_95 * portfolio_value:,.2f} (5% of days exceed this)\")\nprint(f\"  CVaR: ${cvar_95 * portfolio_value:,.2f} (average loss when VaR exceeded)\")\n```\n\n**2. Parametric CVaR (Normal Distribution)**\n\n```python\ndef parametric_cvar(returns, confidence_level=0.95):\n    \"\"\"\n    Calculate CVaR assuming normal distribution\n    \n    Formula: CVaR = Œº - œÉ √ó œÜ(z_Œ±) / (1 - Œ±)\n    Where œÜ = standard normal PDF, z_Œ± = percentile\n    \"\"\"\n    mu = np.mean(returns)\n    sigma = np.std(returns)\n    \n    # Z-score for confidence level\n    z_alpha = stats.norm.ppf(1 - confidence_level)\n    \n    # Parametric VaR\n    var = -(mu + z_alpha * sigma)\n    \n    # Parametric CVaR (Expected Shortfall)\n    # CVaR = Œº - œÉ √ó œÜ(z_Œ±) / (1 - Œ±)\n    phi_z = stats.norm.pdf(z_alpha)  # PDF at z_alpha\n    cvar = -(mu - sigma * phi_z / (1 - confidence_level))\n    \n    return cvar, var\n\ncvar_95_param, var_95_param = parametric_cvar(btc_returns, 0.95)\ncvar_99_param, var_99_param = parametric_cvar(btc_returns, 0.99)\n\nprint(\"\\nüìê PARAMETRIC CVAR (Normal Assumption)\")\nprint(\"=\" * 70)\nprint(f\"95%: VaR = {var_95_param*100:.2f}%, CVaR = {cvar_95_param*100:.2f}%\")\nprint(f\"99%: VaR = {var_99_param*100:.2f}%, CVaR = {cvar_99_param*100:.2f}%\")\n\n# For normal distribution: CVaR/VaR ratio is constant\nratio_95 = cvar_95_param / var_95_param\nratio_99 = cvar_99_param / var_99_param\nprint(f\"\\nCVaR/VaR Ratios: 95% = {ratio_95:.3f}, 99% = {ratio_99:.3f}\")\n```\n\n**3. CVaR via Linear Programming (Optimization)**\n\n```python\nfrom scipy.optimize import linprog\n\ndef cvar_optimization(returns, confidence_level=0.95):\n    \"\"\"\n    Calculate CVaR using linear programming formulation\n    \n    This is the Rockafellar-Uryasev formulation:\n    CVaR_Œ± = min_VaR { VaR + (1/(1-Œ±)) √ó E[max(L - VaR, 0)] }\n    \"\"\"\n    # Convert to losses\n    losses = -returns\n    n_scenarios = len(losses)\n    \n    # For simplicity, use empirical approximation\n    var_threshold = np.percentile(losses, confidence_level * 100)\n    exceedances = losses - var_threshold\n    exceedances[exceedances < 0] = 0\n    \n    cvar = var_threshold + exceedances.mean() / (1 - confidence_level)\n    \n    return cvar\n\ncvar_95_opt = cvar_optimization(btc_returns, 0.95)\nprint(f\"\\nüîß OPTIMIZATION-BASED CVAR\")\nprint(f\"95% CVaR: {cvar_95_opt*100:.2f}%\")\n```\n\n**Multi-Asset Portfolio CVaR:**\n\n```python\ndef portfolio_cvar(returns_df, weights, confidence_level=0.95):\n    \"\"\"\n    Calculate CVaR for multi-asset portfolio\n    \"\"\"\n    # Portfolio returns\n    portfolio_returns = (returns_df * weights).sum(axis=1)\n    \n    # Calculate CVaR\n    cvar, var = historical_cvar(portfolio_returns.values, confidence_level)\n    \n    return cvar, var\n\n# Example: 5-asset crypto portfolio\nnp.random.seed(42)\nassets = ['BTC', 'ETH', 'BNB', 'ADA', 'SOL']\nreturns_df = pd.DataFrame({\n    'BTC': np.random.normal(0.0008, 0.03, 252),\n    'ETH': np.random.normal(0.0010, 0.04, 252),\n    'BNB': np.random.normal(0.0012, 0.05, 252),\n    'ADA': np.random.normal(0.0015, 0.06, 252),\n    'SOL': np.random.normal(0.0018, 0.07, 252)\n})\n\nweights = np.array([0.35, 0.25, 0.20, 0.12, 0.08])\n\nport_cvar_95, port_var_95 = portfolio_cvar(returns_df, weights, 0.95)\nport_cvar_99, port_var_99 = portfolio_cvar(returns_df, weights, 0.99)\n\nprint(\"\\nüíº PORTFOLIO CVAR\")\nprint(\"=\" * 70)\nprint(\"Weights:\", {asset: f\"{w*100:.1f}%\" for asset, w in zip(assets, weights)})\nprint(f\"\\n95% Level:\")\nprint(f\"  VaR:  {port_var_95*100:.2f}%\")\nprint(f\"  CVaR: {port_cvar_95*100:.2f}% ({(port_cvar_95/port_var_95-1)*100:+.1f}% worse than VaR)\")\nprint(f\"\\n99% Level:\")\nprint(f\"  VaR:  {port_var_99*100:.2f}%\")\nprint(f\"  CVaR: {port_cvar_99*100:.2f}% ({(port_cvar_99/port_var_99-1)*100:+.1f}% worse than VaR)\")\n```\n\n**Crypto-Specific CVaR Adaptations:**\n\n**1. Fat-Tailed CVaR (Student's t-distribution)**\n\n```python\ndef fat_tailed_cvar(returns, confidence_level=0.95):\n    \"\"\"\n    Calculate CVaR using Student's t-distribution\n    Better captures crypto's extreme tails\n    \"\"\"\n    # Fit t-distribution\n    params = stats.t.fit(returns)\n    df, loc, scale = params\n    \n    # VaR from t-distribution\n    var = -stats.t.ppf(1 - confidence_level, df, loc, scale)\n    \n    # CVaR from t-distribution (analytical formula)\n    # ES_t = -Œº - œÉ √ó [t_ŒΩ(z_Œ±) √ó (ŒΩ + z_Œ±¬≤) / ((ŒΩ - 1) √ó (1 - Œ±))]\n    # where t_ŒΩ is Student's t PDF\n    \n    z_alpha = stats.t.ppf(1 - confidence_level, df)\n    pdf_z = stats.t.pdf(z_alpha, df)\n    \n    # Simplified approximation for CVaR\n    cvar = var * (1 + (pdf_z * (df + z_alpha**2)) / ((df - 1) * (1 - confidence_level)))\n    \n    return cvar, var, df\n\ncvar_95_t, var_95_t, df = fat_tailed_cvar(btc_returns, 0.95)\ncvar_99_t, var_99_t, _ = fat_tailed_cvar(btc_returns, 0.99)\n\nprint(\"\\nüìâ FAT-TAILED CVAR (Student's t)\")\nprint(\"=\" * 70)\nprint(f\"Degrees of freedom: {df:.2f}\")\nprint(f\"\\n95%: VaR = {var_95_t*100:.2f}%, CVaR = {cvar_95_t*100:.2f}%\")\nprint(f\"99%: VaR = {var_99_t*100:.2f}%, CVaR = {cvar_99_t*100:.2f}%\")\nprint(f\"\\nCompare to Normal:\")\nprint(f\"95% CVaR: {cvar_95_t*100:.2f}% (t) vs {cvar_95_param*100:.2f}% (normal)\")\nprint(f\"Difference: {(cvar_95_t - cvar_95_param)*100:+.2f}% (t-dist captures more tail risk)\")\n```\n\n**2. CVaR Portfolio Optimization**\n\nMinimize CVaR instead of variance:\n\n```python\nfrom scipy.optimize import minimize\n\ndef minimize_cvar_portfolio(returns_df, confidence_level=0.95, target_return=None):\n    \"\"\"\n    Optimize portfolio to minimize CVaR\n    \n    Args:\n        returns_df: DataFrame of asset returns\n        confidence_level: CVaR confidence level\n        target_return: Minimum expected return (optional)\n    \n    Returns:\n        Optimal weights that minimize CVaR\n    \"\"\"\n    n_assets = len(returns_df.columns)\n    \n    def objective(weights):\n        \"\"\"Minimize portfolio CVaR\"\"\"\n        portfolio_returns = (returns_df.values * weights).sum(axis=1)\n        cvar, _ = historical_cvar(portfolio_returns, confidence_level)\n        return cvar\n    \n    # Constraints\n    constraints = [{'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0}]\n    \n    # Add return constraint if specified\n    if target_return is not None:\n        mean_returns = returns_df.mean().values\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda w: np.sum(w * mean_returns) - target_return\n        })\n    \n    # Bounds: long-only\n    bounds = tuple((0, 1) for _ in range(n_assets))\n    \n    # Initial guess\n    initial_weights = np.array([1/n_assets] * n_assets)\n    \n    # Optimize\n    result = minimize(\n        objective,\n        initial_weights,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints\n    )\n    \n    return result.x\n\n# Find minimum CVaR portfolio\nmin_cvar_weights = minimize_cvar_portfolio(returns_df, confidence_level=0.95)\n\nprint(\"\\nüéØ MINIMUM CVAR PORTFOLIO\")\nprint(\"=\" * 70)\nfor asset, weight in zip(assets, min_cvar_weights):\n    print(f\"  {asset}: {weight*100:.2f}%\")\n\n# Calculate CVaR for this portfolio\nopt_cvar, opt_var = portfolio_cvar(returns_df, min_cvar_weights, 0.95)\nprint(f\"\\nOptimized Portfolio:\")\nprint(f\"  95% VaR:  {opt_var*100:.2f}%\")\nprint(f\"  95% CVaR: {opt_cvar*100:.2f}%\")\n\n# Compare to equal-weight\neq_weights = np.array([0.20] * 5)\neq_cvar, eq_var = portfolio_cvar(returns_df, eq_weights, 0.95)\nprint(f\"\\nEqual-Weight Portfolio:\")\nprint(f\"  95% CVaR: {eq_cvar*100:.2f}%\")\nprint(f\"\\nImprovement: {(eq_cvar - opt_cvar)*100:.2f}% reduction in CVaR\")\n```\n\n**3. Component CVaR (Risk Contribution)**\n\n```python\ndef component_cvar(returns_df, weights, confidence_level=0.95):\n    \"\"\"\n    Decompose portfolio CVaR by asset contribution\n    \"\"\"\n    portfolio_returns = (returns_df * weights).sum(axis=1)\n    port_cvar, port_var = historical_cvar(portfolio_returns.values, confidence_level)\n    \n    # Component CVaR (Euler decomposition)\n    component_cvars = []\n    \n    for i in range(len(weights)):\n        # Marginal CVaR: ‚àÇCVaR/‚àÇw_i\n        delta_w = 0.01\n        weights_plus = weights.copy()\n        weights_plus[i] += delta_w\n        weights_plus = weights_plus / weights_plus.sum()\n        \n        portfolio_returns_plus = (returns_df.values * weights_plus).sum(axis=1)\n        cvar_plus, _ = historical_cvar(portfolio_returns_plus, confidence_level)\n        \n        marginal_cvar = (cvar_plus - port_cvar) / delta_w\n        component_cvar_i = weights[i] * marginal_cvar\n        component_cvars.append(component_cvar_i)\n    \n    return np.array(component_cvars), port_cvar\n\ncomp_cvars, total_cvar = component_cvar(returns_df, weights, 0.95)\n\nprint(\"\\nüîç COMPONENT CVAR ANALYSIS\")\nprint(\"=\" * 70)\nprint(f\"Portfolio 95% CVaR: {total_cvar*100:.2f}%\\n\")\nprint(f\"{'Asset':<8} {'Weight':<12} {'Component CVaR':<18} {'% of Total'}\")\nprint(\"-\" * 70)\nfor asset, w, ccv in zip(assets, weights, comp_cvars):\n    pct_contribution = (ccv / total_cvar) * 100 if total_cvar != 0 else 0\n    print(f\"{asset:<8} {w*100:>6.1f}%      {ccv*100:>8.3f}%          {pct_contribution:>8.1f}%\")\n```\n\n**4. Dynamic CVaR (Time-Varying)**\n\n```python\ndef rolling_cvar(returns, confidence_level=0.95, window=100):\n    \"\"\"\n    Calculate rolling CVaR over time\n    Captures changing tail risk in crypto markets\n    \"\"\"\n    cvar_series = []\n    var_series = []\n    \n    for i in range(window, len(returns)):\n        window_returns = returns[i-window:i]\n        cvar, var = historical_cvar(window_returns, confidence_level)\n        cvar_series.append(cvar)\n        var_series.append(var)\n    \n    return np.array(cvar_series), np.array(var_series)\n\nrolling_cvars, rolling_vars = rolling_cvar(btc_returns, 0.95, window=60)\n\nprint(\"\\n‚è±Ô∏è  ROLLING CVAR (60-day window)\")\nprint(\"=\" * 70)\nprint(f\"Current CVaR: {rolling_cvars[-1]*100:.2f}%\")\nprint(f\"Average CVaR: {rolling_cvars.mean()*100:.2f}%\")\nprint(f\"Max CVaR: {rolling_cvars.max()*100:.2f}% (highest tail risk period)\")\nprint(f\"Min CVaR: {rolling_cvars.min()*100:.2f}% (lowest tail risk period)\")\nprint(f\"\\nVolatility of CVaR: {rolling_cvars.std()*100:.2f}% (regime instability)\")\n```\n\n**CVaR Backtesting:**\n\n```python\ndef cvar_backtest(returns, confidence_level=0.95, window=252):\n    \"\"\"\n    Backtest CVaR model accuracy\n    \n    Check if actual average tail loss ‚âà predicted CVaR\n    \"\"\"\n    predicted_cvars = []\n    actual_tail_losses = []\n    \n    for i in range(window, len(returns)):\n        # Calculate CVaR using historical window\n        historical_window = returns[i-window:i]\n        predicted_cvar, predicted_var = historical_cvar(historical_window, confidence_level)\n        \n        # Actual loss for next day\n        actual_loss = -returns[i]\n        \n        # If loss exceeds VaR, record it\n        if actual_loss >= predicted_var:\n            actual_tail_losses.append(actual_loss)\n            predicted_cvars.append(predicted_cvar)\n    \n    # Compare predicted vs. actual\n    if len(actual_tail_losses) > 0:\n        avg_actual_tail_loss = np.mean(actual_tail_losses)\n        avg_predicted_cvar = np.mean(predicted_cvars)\n        \n        return {\n            'n_tail_events': len(actual_tail_losses),\n            'avg_predicted_cvar': avg_predicted_cvar,\n            'avg_actual_tail_loss': avg_actual_tail_loss,\n            'prediction_error': avg_actual_tail_loss - avg_predicted_cvar\n        }\n    else:\n        return {'n_tail_events': 0}\n\nbacktest = cvar_backtest(btc_returns, 0.95, window=100)\n\nif backtest['n_tail_events'] > 0:\n    print(\"\\nüß™ CVAR BACKTESTING\")\n    print(\"=\" * 70)\n    print(f\"Tail events observed: {backtest['n_tail_events']}\")\n    print(f\"Predicted CVaR (avg): {backtest['avg_predicted_cvar']*100:.2f}%\")\n    print(f\"Actual tail loss (avg): {backtest['avg_actual_tail_loss']*100:.2f}%\")\n    print(f\"Prediction error: {backtest['prediction_error']*100:+.2f}%\")\n    \n    error_pct = (backtest['prediction_error'] / backtest['avg_predicted_cvar']) * 100\n    if abs(error_pct) < 10:\n        print(\"\\n‚úÖ CVaR model is well-calibrated (error < 10%)\")\n    else:\n        print(f\"\\n‚ö†Ô∏è  CVaR model has {error_pct:+.1f}% error\")\nelse:\n    print(\"\\n‚ö†Ô∏è  No tail events observed in backtest period\")\n```\n\n**CVaR vs. VaR Comparison:**\n\n```python\ndef compare_var_cvar(returns, confidence_levels=[0.90, 0.95, 0.99]):\n    \"\"\"\n    Comprehensive comparison of VaR vs. CVaR\n    \"\"\"\n    print(\"\\n‚öñÔ∏è  VAR vs. CVAR COMPARISON\")\n    print(\"=\" * 80)\n    print(f\"{'Confidence':<12} {'VaR':<12} {'CVaR':<12} {'CVaR/VaR':<12} {'Extra Risk'}\")\n    print(\"-\" * 80)\n    \n    for conf in confidence_levels:\n        cvar, var = historical_cvar(returns, conf)\n        ratio = cvar / var\n        extra = (ratio - 1) * 100\n        \n        print(f\"{conf*100:<11.0f}%  {var*100:>7.2f}%     {cvar*100:>7.2f}%     {ratio:>7.3f}      {extra:>+6.1f}%\")\n\ncompare_var_cvar(btc_returns)\n```\n\n**Practical CVaR Guidelines for Crypto:**\n\n**When to Use CVaR:**\n\n‚úÖ **Always prefer CVaR over VaR for:**\n- Portfolio optimization (CVaR is convex)\n- Risk capital allocation\n- Stress testing\n- Regulatory reporting (Basel moving to ES)\n- Tail risk management\n\n**Confidence Levels:**\n- 95% CVaR: Daily risk management\n- 97.5% CVaR: Basel III standard (replaced 99% VaR)\n- 99% CVaR: Stress testing\n- 99.5%+ CVaR: Extreme tail analysis\n\n**Advantages Over VaR:**\n\n| Property | VaR | CVaR |\n|----------|-----|------|\n| Tail sensitivity | ‚ùå Ignores | ‚úÖ Captures |\n| Subadditivity | ‚ùå Violated | ‚úÖ Satisfied |\n| Optimization | ‚ö†Ô∏è Difficult | ‚úÖ Convex |\n| Coherent | ‚ùå No | ‚úÖ Yes |\n| Extreme events | ‚ö†Ô∏è Underestimates | ‚úÖ Better estimate |\n| Crypto suitability | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |\n\n**Implementation Recommendations:**\n\n1. **Use Historical CVaR for crypto** - No distribution assumptions\n2. **Short lookback (3-6 months)** - Crypto regimes change fast\n3. **Combine with stress tests** - CVaR is historical, stress tests are forward-looking\n4. **Monitor CVaR/VaR ratio** - Rising ratio = fattening tails\n5. **Component CVaR for attribution** - Understand which assets drive tail risk\n\n**CVaR-Based Risk Limits:**\n\n```python\n# Example risk limit framework\nportfolio_value = 1000000  # $1M\n\n# Risk limits\nmax_daily_cvar_95 = 0.05  # 5% of portfolio\nmax_weekly_cvar_95 = 0.10  # 10% of portfolio\n\nprint(\"\\nüö® RISK LIMIT FRAMEWORK\")\nprint(\"=\" * 70)\nprint(f\"Portfolio Value: ${portfolio_value:,}\")\nprint(f\"\\nDaily Limits (95% CVaR):\")\nprint(f\"  Maximum: ${max_daily_cvar_95 * portfolio_value:,.0f}\")\nprint(f\"  Current: ${cvar_95 * portfolio_value:,.0f}\")\n\nif cvar_95 <= max_daily_cvar_95:\n    print(f\"  Status: ‚úÖ Within limit\")\nelse:\n    print(f\"  Status: üö® BREACH - Reduce risk!\")\n```\n\n**Key Insights:**\n\n1. **CVaR > VaR always** - CVaR is always worse (higher loss) than VaR\n2. **Typical CVaR/VaR ratio: 1.2-1.5x** - For crypto, often higher\n3. **Fat tails ‚Üí higher CVaR/VaR** - Crypto has 2-3x normal distribution tails\n4. **CVaR is optimization-friendly** - Can minimize CVaR directly\n5. **Regulatory shift to CVaR** - Basel III uses Expected Shortfall (CVaR)\n\n**Academic Sources:**\n- Rockafellar, R.T., Uryasev, S. (2000). \"Optimization of Conditional Value-at-Risk.\" Journal of Risk.\n- Acerbi, C., Tasche, D. (2002). \"On the Coherence of Expected Shortfall.\" Journal of Banking & Finance.\n- \"CVaR for Cryptocurrency Portfolios\" - Quantitative Finance (2021)\n- Basel Committee (2016). \"Minimum Capital Requirements for Market Risk\" (ES/CVaR based)\n- Yamai, Y., Yoshiba, T. (2005). \"Value-at-Risk versus Expected Shortfall.\" Monetary and Economic Studies.",
      "category": "Quantitative Finance",
      "subcategory": "Risk Management",
      "difficulty": "Graduate"
    }
  ]
}
