{
  "source": "quant_finance_portfolio_construction",
  "created_at": "2025-11-08",
  "total_pairs": 5,
  "description": "Portfolio Construction Q&A - Mean-variance optimization, Kelly criterion, risk parity for cryptocurrency markets",
  "qa_pairs": [
    {
      "pair_id": "quant_portfolio_001",
      "topic": "Mean-variance optimization portfolio cryptocurrency Markowitz",
      "question": "How can mean-variance optimization (Markowitz portfolio theory) be applied to cryptocurrency portfolio construction, and what are the key adaptations needed for crypto markets?",
      "answer": "Mean-variance optimization (MVO), developed by Harry Markowitz in 1952, is a foundational quantitative portfolio construction method that maximizes expected return for a given level of risk (variance). While originally designed for traditional assets, it can be adapted for cryptocurrency portfolios with important modifications. Here's the comprehensive guide:\n\n**Mean-Variance Optimization Theory:**\n\n**Objective Function:**\nMaximize: E(Rp) - (λ/2)σ²p\n\nWhere:\n- E(Rp) = Expected portfolio return\n- σ²p = Portfolio variance (risk)\n- λ = Risk aversion coefficient (higher λ = more risk-averse)\n\n**Portfolio Return:**\nE(Rp) = Σ wi × E(Ri)\n\nWhere:\n- wi = Weight of asset i in portfolio\n- E(Ri) = Expected return of asset i\n- Σ wi = 1 (weights sum to 100%)\n\n**Portfolio Variance:**\nσ²p = Σ Σ wi × wj × Cov(Ri, Rj)\n\nWhere:\n- Cov(Ri, Rj) = Covariance between assets i and j\n- Diagonal elements (i=j): wi² × σ²i (variance)\n- Off-diagonal: wi × wj × ρij × σi × σj (covariance)\n\n**Efficient Frontier:**\nThe curve showing maximum return for each level of risk, or minimum risk for each level of return.\n\n**Traditional MVO Implementation:**\n\n```python\nimport numpy as np\nimport pandas as pd\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\n\ndef calculate_portfolio_metrics(weights, returns, cov_matrix):\n    \"\"\"\n    Calculate portfolio return and volatility\n    \"\"\"\n    portfolio_return = np.sum(weights * returns)\n    portfolio_std = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))\n    return portfolio_return, portfolio_std\n\ndef mean_variance_optimization(returns, cov_matrix, target_return=None, risk_aversion=1.0):\n    \"\"\"\n    Solve mean-variance optimization\n    \n    Args:\n        returns: Expected returns (numpy array)\n        cov_matrix: Covariance matrix\n        target_return: Target return (if None, use risk aversion)\n        risk_aversion: Lambda parameter (higher = more conservative)\n    \n    Returns:\n        Optimal weights\n    \"\"\"\n    n_assets = len(returns)\n    \n    # Objective function: minimize -return + (lambda/2)*variance\n    def objective(weights):\n        port_return = np.sum(weights * returns)\n        port_variance = np.dot(weights.T, np.dot(cov_matrix, weights))\n        return -(port_return - (risk_aversion / 2) * port_variance)\n    \n    # Constraints\n    constraints = [\n        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0}  # Weights sum to 1\n    ]\n    \n    # If target return specified, add constraint\n    if target_return is not None:\n        constraints.append({\n            'type': 'eq',\n            'fun': lambda w: np.sum(w * returns) - target_return\n        })\n    \n    # Bounds: 0 <= weight <= 1 (long-only)\n    bounds = tuple((0, 1) for _ in range(n_assets))\n    \n    # Initial guess: equal weights\n    initial_weights = np.array([1/n_assets] * n_assets)\n    \n    # Optimize\n    result = minimize(\n        objective,\n        initial_weights,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints\n    )\n    \n    return result.x\n\n# Example: 5-asset crypto portfolio\ncrypto_returns = np.array([0.15, 0.25, 0.35, 0.20, 0.30])  # BTC, ETH, BNB, ADA, SOL\n\n# Historical covariance matrix (annualized)\ncrypto_cov = np.array([\n    [0.16, 0.12, 0.10, 0.09, 0.11],  # BTC\n    [0.12, 0.25, 0.15, 0.13, 0.16],  # ETH\n    [0.10, 0.15, 0.30, 0.14, 0.17],  # BNB\n    [0.09, 0.13, 0.14, 0.36, 0.15],  # ADA\n    [0.11, 0.16, 0.17, 0.15, 0.40]   # SOL\n])\n\n# Find optimal portfolio\noptimal_weights = mean_variance_optimization(crypto_returns, crypto_cov, risk_aversion=2.0)\n\nprint(\"Optimal Portfolio Weights:\")\nfor i, weight in enumerate(optimal_weights):\n    print(f\"Asset {i+1}: {weight*100:.2f}%\")\n\nport_return, port_std = calculate_portfolio_metrics(optimal_weights, crypto_returns, crypto_cov)\nprint(f\"\\nExpected Return: {port_return*100:.2f}%\")\nprint(f\"Expected Volatility: {port_std*100:.2f}%\")\nprint(f\"Sharpe Ratio: {port_return/port_std:.2f}\")\n```\n\n**Crypto-Specific Adaptations:**\n\n**1. Extreme Volatility Adjustment**\n\nCrypto volatility is 3-5x higher than stocks:\n\n```python\n# Robust covariance estimation (Ledoit-Wolf shrinkage)\nfrom sklearn.covariance import LedoitWolf\n\ndef robust_covariance_crypto(returns_df):\n    \"\"\"\n    Estimate covariance with shrinkage for crypto's extreme volatility\n    \"\"\"\n    lw = LedoitWolf()\n    cov_matrix = lw.fit(returns_df).covariance_\n    return cov_matrix\n\n# Alternative: Exponentially weighted covariance (recent data weighted more)\ndef ewma_covariance_crypto(returns_df, span=30):\n    \"\"\"\n    EWMA covariance - adapts faster to crypto market regime changes\n    \"\"\"\n    return returns_df.ewm(span=span).cov()\n```\n\n**2. Non-Normal Return Distributions**\n\nCrypto returns have fat tails (high kurtosis):\n\n```python\n# Use CVaR (Conditional Value at Risk) instead of variance\ndef cvar_optimization(returns_data, confidence_level=0.95):\n    \"\"\"\n    Minimize CVaR instead of variance for better tail risk management\n    \"\"\"\n    n_scenarios, n_assets = returns_data.shape\n    \n    def objective(weights):\n        portfolio_returns = returns_data @ weights\n        var_threshold = np.percentile(portfolio_returns, (1-confidence_level)*100)\n        cvar = -portfolio_returns[portfolio_returns <= var_threshold].mean()\n        return cvar\n    \n    constraints = [{'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0}]\n    bounds = tuple((0, 1) for _ in range(n_assets))\n    initial = np.array([1/n_assets] * n_assets)\n    \n    result = minimize(objective, initial, method='SLSQP', bounds=bounds, constraints=constraints)\n    return result.x\n```\n\n**3. Time-Varying Correlations**\n\nCrypto correlations change rapidly during bull/bear markets:\n\n```python\n# Dynamic correlation (DCC-GARCH model)\nfrom arch import arch_model\n\ndef dynamic_correlation_portfolio(returns_df):\n    \"\"\"\n    Account for time-varying correlations in crypto\n    \"\"\"\n    # Fit GARCH models to each asset\n    volatilities = {}\n    for col in returns_df.columns:\n        model = arch_model(returns_df[col], vol='Garch', p=1, q=1)\n        result = model.fit(disp='off')\n        volatilities[col] = result.conditional_volatility\n    \n    # Estimate dynamic correlations\n    # Use recent window (e.g., 30 days) for portfolio optimization\n    recent_cov = returns_df.tail(30).cov()\n    return recent_cov\n```\n\n**4. Constraints for Crypto Portfolios**\n\n```python\ndef crypto_mvo_with_constraints(returns, cov_matrix, min_btc=0.3, max_altcoin=0.15):\n    \"\"\"\n    MVO with crypto-specific constraints:\n    - Minimum BTC allocation (30%) for stability\n    - Maximum per altcoin (15%) for risk management\n    - No short selling (long-only)\n    \"\"\"\n    n_assets = len(returns)\n    \n    def objective(weights):\n        port_return = np.sum(weights * returns)\n        port_variance = np.dot(weights.T, np.dot(cov_matrix, weights))\n        sharpe = port_return / np.sqrt(port_variance)\n        return -sharpe  # Maximize Sharpe\n    \n    # Constraints\n    constraints = [\n        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0},  # Weights sum to 1\n        {'type': 'ineq', 'fun': lambda w: w[0] - min_btc}   # BTC >= 30%\n    ]\n    \n    # Bounds: BTC [0.3, 1.0], Altcoins [0, 0.15]\n    bounds = [(min_btc, 1.0)] + [(0, max_altcoin)] * (n_assets - 1)\n    \n    initial = np.array([min_btc] + [(1-min_btc)/(n_assets-1)] * (n_assets-1))\n    result = minimize(objective, initial, method='SLSQP', bounds=bounds, constraints=constraints)\n    \n    return result.x\n```\n\n**5. Transaction Costs & Rebalancing**\n\nCrypto has higher transaction costs:\n\n```python\ndef mvo_with_transaction_costs(returns, cov_matrix, current_weights, transaction_cost=0.001):\n    \"\"\"\n    Incorporate transaction costs (0.1% = 0.001)\n    Only rebalance if benefit > cost\n    \"\"\"\n    n_assets = len(returns)\n    \n    def objective_with_costs(new_weights):\n        # Expected return\n        port_return = np.sum(new_weights * returns)\n        \n        # Risk\n        port_variance = np.dot(new_weights.T, np.dot(cov_matrix, new_weights))\n        \n        # Transaction cost (proportional to turnover)\n        turnover = np.sum(np.abs(new_weights - current_weights))\n        cost = turnover * transaction_cost\n        \n        # Net return after costs\n        net_return = port_return - cost\n        \n        # Maximize Sharpe with costs\n        return -(net_return / np.sqrt(port_variance))\n    \n    constraints = [{'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0}]\n    bounds = tuple((0, 1) for _ in range(n_assets))\n    \n    result = minimize(objective_with_costs, current_weights, method='SLSQP', bounds=bounds, constraints=constraints)\n    \n    # Only rebalance if improvement > threshold\n    if objective_with_costs(result.x) < objective_with_costs(current_weights) - 0.01:\n        return result.x\n    else:\n        return current_weights  # Keep current allocation\n```\n\n**Key Challenges in Crypto MVO:**\n\n**1. Estimation Error:**\n- Expected returns hard to estimate (crypto is young)\n- Solution: Use Bayesian methods, Black-Litterman model\n\n**2. Regime Changes:**\n- Bull market: High correlations (everything rises)\n- Bear market: Flight to BTC (correlations shift)\n- Solution: Regime-switching models, rolling windows\n\n**3. New Asset Additions:**\n- New coins launched frequently\n- Limited historical data\n- Solution: Shrinkage estimators, factor models\n\n**Practical Crypto Portfolio Example:**\n\n```python\n# Realistic crypto portfolio optimization\nimport pandas as pd\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# 10 crypto assets\nassets = ['BTC', 'ETH', 'BNB', 'ADA', 'SOL', 'DOT', 'AVAX', 'MATIC', 'LINK', 'UNI']\n\n# Load historical returns (252 trading days)\n# returns_df = pd.read_csv('crypto_returns.csv', index_col='date')\n# Simulated for example:\nnp.random.seed(42)\nreturns_df = pd.DataFrame(\n    np.random.randn(252, 10) * 0.05 + np.array([0.001] * 10),\n    columns=assets\n)\n\n# Calculate inputs\nexpected_returns = returns_df.mean() * 252  # Annualize\ncov_matrix = returns_df.cov() * 252\n\n# Optimize\noptimal = crypto_mvo_with_constraints(\n    expected_returns.values,\n    cov_matrix.values,\n    min_btc=0.25,\n    max_altcoin=0.10\n)\n\nportfolio_df = pd.DataFrame({\n    'Asset': assets,\n    'Weight': optimal,\n    'Expected Return': expected_returns.values,\n})\nportfolio_df = portfolio_df.sort_values('Weight', ascending=False)\n\nprint(portfolio_df.to_string(index=False))\n```\n\n**When to Use MVO for Crypto:**\n- ✅ Long-term portfolios (1+ years)\n- ✅ Diversified holdings (5+ assets)\n- ✅ Risk-conscious investors\n- ✅ Institutional allocations\n\n**When NOT to Use:**\n- ❌ Short-term trading (< 3 months)\n- ❌ During extreme volatility (use CVaR instead)\n- ❌ With leverage (MVO assumes linear risk)\n- ❌ Without robust estimation (garbage in = garbage out)\n\n**Key Differences from Stock MVO:**\n\n| Aspect | Stocks | Crypto |\n|--------|--------|--------|\n| Volatility | 15-30% | 50-150% |\n| Correlations | Stable | Time-varying |\n| Rebalancing | Quarterly | Monthly |\n| Min BTC weight | N/A | 25-40% recommended |\n| Transaction costs | 0.01% | 0.1-1.0% |\n| Market hours | 9:30-4:00 | 24/7 |\n\n**Advanced Extensions:**\n\n1. **Black-Litterman Model** - Incorporate views (\"I believe BTC will outperform\")\n2. **Robust Optimization** - Account for estimation uncertainty\n3. **Multi-Period MVO** - Optimize over time with rebalancing costs\n4. **Factor-Based MVO** - Use crypto-specific factors (DeFi, Layer-1, etc.)\n\n**Sources:**\n- Markowitz, H. (1952). \"Portfolio Selection.\" Journal of Finance.\n- \"Portfolio Optimization for Cryptocurrencies\" - Journal of Risk & Financial Management (2021)\n- \"Cryptocurrency Portfolio Optimization Using Mean-Variance\" - Applied Economics (2020)\n- CryptoQuant Research - Institutional Portfolio Construction (2024-2025)",
      "category": "Quantitative Finance",
      "subcategory": "Portfolio Construction",
      "difficulty": "Graduate"
    }
  ]
}
