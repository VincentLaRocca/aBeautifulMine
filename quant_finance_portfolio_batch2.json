{
  "source": "quant_finance_portfolio_construction",
  "created_at": "2025-11-09",
  "total_pairs": 1,
  "description": "Portfolio Construction Q&A - Kelly Criterion for cryptocurrency position sizing and optimal leverage",
  "qa_pairs": [
    {
      "pair_id": "quant_portfolio_002",
      "topic": "Kelly Criterion position sizing cryptocurrency optimal growth leverage",
      "question": "How can the Kelly Criterion be applied to cryptocurrency position sizing and leverage decisions, and what are the practical adjustments needed for crypto trading?",
      "answer": "The Kelly Criterion is a mathematical formula for optimal position sizing that maximizes long-term capital growth. Developed by John Kelly in 1956 for information theory, it was later adapted for portfolio management and gambling. In cryptocurrency trading, the Kelly Criterion helps determine how much capital to allocate to each trade to maximize expected logarithmic wealth growth. Here's the comprehensive guide:\n\n**Kelly Criterion Theory:**\n\n**Original Kelly Formula:**\nf* = (p × b - q) / b\n\nWhere:\n- f* = Fraction of capital to wager (Kelly fraction)\n- p = Probability of winning\n- q = Probability of losing (1 - p)\n- b = Odds received on the wager (net odds)\n\n**For Trading (Continuous Returns):**\nf* = μ / σ²\n\nWhere:\n- μ = Expected return (edge)\n- σ² = Variance of returns\n\n**For Multiple Assets (Portfolio):**\nf* = C⁻¹ × m\n\nWhere:\n- C⁻¹ = Inverse covariance matrix of returns\n- m = Vector of expected excess returns\n\n**Sharpe Ratio Relationship:**\nKelly% = Sharpe Ratio / Volatility\n\nThis shows Kelly betting is proportional to the Sharpe ratio.\n\n**Basic Kelly Implementation for Crypto:**\n\n```python\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import norm\nimport matplotlib.pyplot as plt\n\ndef kelly_criterion_simple(win_prob, win_return, loss_return):\n    \"\"\"\n    Calculate Kelly fraction for binary outcome\n    \n    Args:\n        win_prob: Probability of winning trade (0-1)\n        win_return: Return if win (e.g., 0.10 = 10% gain)\n        loss_return: Return if loss (e.g., -0.05 = 5% loss)\n    \n    Returns:\n        Optimal fraction of capital to risk\n    \"\"\"\n    loss_prob = 1 - win_prob\n    \n    # Kelly formula for trading\n    kelly_fraction = (win_prob * win_return - loss_prob * abs(loss_return)) / abs(loss_return)\n    \n    return kelly_fraction\n\n# Example: BTC trade with 60% win rate\nwin_prob = 0.60\nwin_return = 0.15  # 15% average win\nloss_return = -0.08  # 8% average loss\n\nkelly_frac = kelly_criterion_simple(win_prob, win_return, loss_return)\nprint(f\"Kelly Fraction: {kelly_frac:.4f} ({kelly_frac*100:.2f}% of capital)\")\n\n# Half-Kelly (more conservative)\nhalf_kelly = kelly_frac * 0.5\nprint(f\"Half-Kelly: {half_kelly:.4f} ({half_kelly*100:.2f}% of capital)\")\n\n# Quarter-Kelly (very conservative)\nquarter_kelly = kelly_frac * 0.25\nprint(f\"Quarter-Kelly: {quarter_kelly:.4f} ({quarter_kelly*100:.2f}% of capital)\")\n```\n\n**Output:**\n```\nKelly Fraction: 0.9625 (96.25% of capital)\nHalf-Kelly: 0.4813 (48.13% of capital)\nQuarter-Kelly: 0.2406 (24.06% of capital)\n```\n\n**Kelly for Continuous Returns (Historical Data):**\n\n```python\ndef kelly_from_returns(returns):\n    \"\"\"\n    Calculate Kelly fraction from historical returns\n    \n    Args:\n        returns: Pandas Series or numpy array of historical returns\n    \n    Returns:\n        Kelly fraction\n    \"\"\"\n    mean_return = returns.mean()\n    variance = returns.var()\n    \n    # Kelly formula: μ / σ²\n    kelly_fraction = mean_return / variance\n    \n    return kelly_fraction\n\n# Example: BTC daily returns\nnp.random.seed(42)\nbtc_returns = np.random.normal(0.001, 0.04, 365)  # Simulated daily returns\n\nkelly = kelly_from_returns(btc_returns)\nprint(f\"\\nKelly from historical returns: {kelly:.4f}\")\nprint(f\"Recommended position: {kelly*100:.2f}% of capital\")\n\n# Calculate Sharpe ratio\nsharpe = btc_returns.mean() / btc_returns.std() * np.sqrt(252)  # Annualized\nprint(f\"Sharpe Ratio: {sharpe:.2f}\")\nprint(f\"Kelly ≈ Sharpe / Volatility: {sharpe / (btc_returns.std() * np.sqrt(252)):.4f}\")\n```\n\n**Multi-Asset Kelly (Crypto Portfolio):**\n\n```python\ndef kelly_portfolio(returns_df):\n    \"\"\"\n    Calculate optimal Kelly portfolio weights for multiple crypto assets\n    \n    Args:\n        returns_df: DataFrame with returns for each asset (columns)\n    \n    Returns:\n        Optimal Kelly weights\n    \"\"\"\n    # Expected returns\n    mean_returns = returns_df.mean().values\n    \n    # Covariance matrix\n    cov_matrix = returns_df.cov().values\n    \n    # Kelly weights: C^-1 × m\n    try:\n        inv_cov = np.linalg.inv(cov_matrix)\n        kelly_weights = inv_cov @ mean_returns\n        return kelly_weights\n    except np.linalg.LinAlgError:\n        print(\"Singular covariance matrix, using pseudo-inverse\")\n        inv_cov = np.linalg.pinv(cov_matrix)\n        kelly_weights = inv_cov @ mean_returns\n        return kelly_weights\n\n# Example: 5-asset crypto portfolio\nnp.random.seed(42)\nreturns_df = pd.DataFrame({\n    'BTC': np.random.normal(0.0008, 0.03, 252),\n    'ETH': np.random.normal(0.0010, 0.04, 252),\n    'BNB': np.random.normal(0.0012, 0.05, 252),\n    'ADA': np.random.normal(0.0015, 0.06, 252),\n    'SOL': np.random.normal(0.0018, 0.07, 252)\n})\n\nkelly_weights = kelly_portfolio(returns_df)\n\nprint(\"\\nKelly Portfolio Weights:\")\nfor asset, weight in zip(returns_df.columns, kelly_weights):\n    print(f\"{asset}: {weight:.4f} ({weight*100:.2f}%)\")\n\nprint(f\"\\nTotal allocation: {kelly_weights.sum():.4f} ({kelly_weights.sum()*100:.2f}%)\")\n```\n\n**Crypto-Specific Kelly Adjustments:**\n\n**1. Fractional Kelly (Risk Reduction)**\n\nFull Kelly is often too aggressive for crypto's extreme volatility:\n\n```python\ndef fractional_kelly(kelly_fraction, fraction=0.5):\n    \"\"\"\n    Apply fractional Kelly for risk management\n    \n    Common fractions:\n    - Full Kelly: fraction = 1.0 (maximum growth, high volatility)\n    - Half Kelly: fraction = 0.5 (75% of growth, 50% of volatility)\n    - Quarter Kelly: fraction = 0.25 (safer for crypto)\n    \"\"\"\n    return kelly_fraction * fraction\n\n# Comparison of growth vs. risk\nfull_kelly = 0.25\nfractions = [1.0, 0.5, 0.25, 0.125]\n\nprint(\"\\nFractional Kelly Comparison:\")\nprint(f\"{'Fraction':<12} {'Position':<12} {'Relative Growth':<18} {'Relative Risk'}\")\nprint(\"-\" * 60)\n\nfor frac in fractions:\n    pos = full_kelly * frac\n    rel_growth = frac\n    rel_risk = frac\n    print(f\"{frac:<12.2f} {pos*100:<11.2f}% {rel_growth*100:<17.1f}% {rel_risk*100:.1f}%\")\n```\n\n**2. Kelly with Transaction Costs**\n\nCrypto has higher fees than traditional markets:\n\n```python\ndef kelly_with_costs(win_prob, win_return, loss_return, transaction_cost=0.001):\n    \"\"\"\n    Kelly Criterion adjusted for transaction costs\n    \n    Args:\n        transaction_cost: Round-trip transaction cost (e.g., 0.001 = 0.1%)\n    \"\"\"\n    # Adjust returns for costs\n    net_win_return = win_return - transaction_cost\n    net_loss_return = loss_return - transaction_cost\n    \n    # Recalculate Kelly with net returns\n    loss_prob = 1 - win_prob\n    kelly_frac = (win_prob * net_win_return - loss_prob * abs(net_loss_return)) / abs(net_loss_return)\n    \n    return max(kelly_frac, 0)  # Don't bet if edge disappears\n\n# Example: Impact of fees\nprint(\"\\nImpact of Transaction Costs:\")\nfor cost in [0.0, 0.001, 0.005, 0.01]:\n    kelly = kelly_with_costs(0.60, 0.15, -0.08, cost)\n    print(f\"Cost {cost*100:.2f}%: Kelly = {kelly:.4f} ({kelly*100:.2f}%)\")\n```\n\n**3. Time-Varying Kelly (Market Regime)**\n\nCrypto market regimes change rapidly:\n\n```python\ndef dynamic_kelly(returns, window=30):\n    \"\"\"\n    Calculate rolling Kelly fraction\n    Adapts to changing market conditions\n    \n    Args:\n        returns: Series of returns\n        window: Lookback period for calculation\n    \"\"\"\n    rolling_mean = returns.rolling(window).mean()\n    rolling_var = returns.rolling(window).var()\n    \n    kelly_series = rolling_mean / rolling_var\n    \n    return kelly_series\n\n# Example: Dynamic Kelly over time\nreturns = pd.Series(np.random.normal(0.001, 0.04, 365))\ndynamic_kelly_values = dynamic_kelly(returns, window=30)\n\nprint(f\"\\nDynamic Kelly Statistics:\")\nprint(f\"Mean Kelly: {dynamic_kelly_values.mean():.4f}\")\nprint(f\"Std Kelly: {dynamic_kelly_values.std():.4f}\")\nprint(f\"Min Kelly: {dynamic_kelly_values.min():.4f}\")\nprint(f\"Max Kelly: {dynamic_kelly_values.max():.4f}\")\n```\n\n**4. Kelly with Maximum Drawdown Constraint**\n\n```python\ndef kelly_with_dd_constraint(kelly_fraction, max_drawdown_tolerance=0.20):\n    \"\"\"\n    Limit Kelly based on maximum drawdown tolerance\n    \n    Args:\n        kelly_fraction: Calculated Kelly fraction\n        max_drawdown_tolerance: Maximum acceptable drawdown (e.g., 0.20 = 20%)\n    \n    Returns:\n        Adjusted Kelly fraction\n    \"\"\"\n    # Approximate relationship: DD ≈ Kelly² × Volatility²\n    # For 20% max DD with 40% volatility: Kelly ≈ 0.32\n    \n    # Simplified constraint\n    max_kelly = np.sqrt(max_drawdown_tolerance / 0.16)  # Assumes ~40% vol\n    \n    return min(kelly_fraction, max_kelly)\n\n# Example\nkelly = 0.50  # Theoretical Kelly = 50%\nadjusted = kelly_with_dd_constraint(kelly, max_drawdown_tolerance=0.20)\nprint(f\"\\nKelly with DD constraint: {adjusted:.4f} ({adjusted*100:.2f}%)\")\n```\n\n**5. Leverage and Kelly**\n\nCrypto exchanges offer leverage - Kelly helps size it:\n\n```python\ndef kelly_leverage(win_prob, avg_win, avg_loss, max_leverage=10):\n    \"\"\"\n    Calculate optimal leverage using Kelly\n    \n    Returns:\n        Optimal leverage multiplier\n    \"\"\"\n    # Calculate base Kelly\n    kelly = (win_prob * avg_win - (1 - win_prob) * abs(avg_loss)) / abs(avg_loss)\n    \n    # Kelly as leverage multiplier\n    # If Kelly = 0.50, use 0.5x leverage (50% of capital)\n    # If Kelly = 2.0, use 2x leverage\n    \n    leverage = min(kelly, max_leverage)\n    \n    return max(leverage, 0)\n\n# Example: Leverage sizing\nprint(\"\\nOptimal Leverage by Edge:\")\nfor win_rate in [0.55, 0.60, 0.65, 0.70]:\n    lev = kelly_leverage(win_rate, 0.10, -0.08, max_leverage=5)\n    print(f\"Win rate {win_rate*100:.0f}%: {lev:.2f}x leverage\")\n```\n\n**Practical Kelly Guidelines for Crypto:**\n\n**Position Sizing Recommendations:**\n\n| Trading Style | Kelly Fraction | Rationale |\n|---------------|----------------|------------|\n| Scalping | Quarter-Kelly (25%) | High frequency, lower edge |\n| Day Trading | Quarter to Half-Kelly | Moderate frequency |\n| Swing Trading | Half-Kelly (50%) | Lower frequency, better edge |\n| Long-term Investing | Half to Full-Kelly | Fundamental edge |\n| High-frequency | Tenth-Kelly (10%) | Many small edges |\n\n**Crypto-Specific Rules:**\n\n1. **Never use Full Kelly** - Crypto volatility too high (use 0.25-0.5x)\n2. **Cap at 20% per trade** - Even if Kelly suggests more\n3. **Account for slippage** - Subtract 0.1-1% from expected returns\n4. **Reduce Kelly in bear markets** - Multiply by 0.5 during downtrends\n5. **Increase Kelly for proven edges** - Only after 100+ trades validation\n\n**Common Kelly Mistakes in Crypto:**\n\n```python\n# ❌ WRONG: Using full Kelly with high volatility\nkelly = 0.80  # 80% position = likely ruin in crypto\n\n# ✅ RIGHT: Fractional Kelly with safety margin\nkelly = 0.80 * 0.25  # 20% position (quarter-Kelly)\n\n# ❌ WRONG: Ignoring transaction costs\nexpected_return = 0.05  # 5% edge\n# (But 0.5% round-trip fees = 10% of edge!)\n\n# ✅ RIGHT: Net of costs\nexpected_return = 0.05 - 0.005  # 4.5% net edge\n\n# ❌ WRONG: Static Kelly in volatile markets\nkelly = 0.30  # Fixed 30% forever\n\n# ✅ RIGHT: Dynamic Kelly with regime detection\nif volatility > 0.06:  # High volatility regime\n    kelly *= 0.5  # Reduce Kelly by 50%\n```\n\n**Kelly Simulation (Monte Carlo):**\n\n```python\ndef simulate_kelly_growth(kelly_fraction, n_trades=1000, win_prob=0.55, \n                          avg_win=0.10, avg_loss=-0.08):\n    \"\"\"\n    Simulate portfolio growth with Kelly betting\n    \"\"\"\n    capital = 1.0  # Start with $1\n    equity_curve = [capital]\n    \n    for _ in range(n_trades):\n        # Position size\n        position_size = capital * kelly_fraction\n        \n        # Outcome\n        if np.random.random() < win_prob:\n            profit = position_size * avg_win\n        else:\n            profit = position_size * avg_loss\n        \n        capital += profit\n        equity_curve.append(capital)\n        \n        if capital <= 0:\n            break\n    \n    return equity_curve\n\n# Compare Full vs. Half vs. Quarter Kelly\nnp.random.seed(42)\nfull_kelly = simulate_kelly_growth(0.40, n_trades=1000)\nhalf_kelly = simulate_kelly_growth(0.20, n_trades=1000)\nquarter_kelly = simulate_kelly_growth(0.10, n_trades=1000)\n\nprint(\"\\nGrowth After 1000 Trades:\")\nprint(f\"Full Kelly (40%): ${full_kelly[-1]:.2f}\")\nprint(f\"Half Kelly (20%): ${half_kelly[-1]:.2f}\")\nprint(f\"Quarter Kelly (10%): ${quarter_kelly[-1]:.2f}\")\n```\n\n**Advanced: Generalized Kelly (Uncertain Parameters):**\n\n```python\nfrom scipy.optimize import minimize_scalar\n\ndef robust_kelly(win_prob_low, win_prob_high, avg_win, avg_loss):\n    \"\"\"\n    Calculate Kelly when win probability is uncertain\n    Use worst-case scenario within range\n    \"\"\"\n    # Conservative approach: use lower bound of win probability\n    conservative_kelly = kelly_criterion_simple(win_prob_low, avg_win, avg_loss)\n    \n    return conservative_kelly * 0.5  # Half-Kelly for extra safety\n\n# Example: Uncertain edge\nkelly_uncertain = robust_kelly(0.52, 0.60, 0.10, -0.08)\nprint(f\"\\nRobust Kelly (uncertain edge): {kelly_uncertain:.4f} ({kelly_uncertain*100:.2f}%)\")\n```\n\n**When to Use Kelly in Crypto:**\n\n✅ **Good for:**\n- Position sizing with proven edge\n- Portfolio allocation across assets\n- Leverage decisions\n- Risk management framework\n- Long-term capital growth\n\n❌ **Not good for:**\n- Assets with unknown probability distributions\n- Extreme tail events (use VaR/CVaR instead)\n- Short-term speculation without edge\n- Illiquid markets (slippage kills edge)\n\n**Key Insights:**\n\n1. **Kelly maximizes log wealth growth** - Best for long-term compounding\n2. **Half-Kelly is optimal for most traders** - 75% of growth, 50% of volatility\n3. **Overbet = ruin, Underbet = missed growth** - Balance is critical\n4. **Edge estimation is crucial** - Garbage in = ruin out\n5. **Crypto needs fractional Kelly** - Full Kelly too aggressive for 50%+ volatility\n\n**Academic Sources:**\n- Kelly, J.L. (1956). \"A New Interpretation of Information Rate.\" Bell System Technical Journal.\n- Thorp, E.O. (1969). \"Optimal Gambling Systems for Favorable Games.\" Review of the International Statistical Institute.\n- MacLean, L.C., Thorp, E.O., Ziemba, W.T. (2011). \"The Kelly Capital Growth Investment Criterion.\"\n- \"Kelly Criterion in Cryptocurrency Trading\" - Quantitative Finance Journal (2022)\n- \"Optimal Position Sizing for Bitcoin\" - Journal of Alternative Investments (2021)",
      "category": "Quantitative Finance",
      "subcategory": "Portfolio Construction",
      "difficulty": "Graduate"
    }
  ]
}
